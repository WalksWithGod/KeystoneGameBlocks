using System;
using Keystone.Types;

namespace Keystone.Cameras
{
    /// <summary>
    /// Because each view can have a different view controller, we can still use
    /// a single InputController but with different zoom behavior defined/handled by each ViewController
    /// </summary>
    public class ViewpointController
    {
        protected RenderingContext mContext;
        
        private System.Drawing.Point mScreenPosition;
                
        #region axis state vars

        // Because each view can have a different view controller, we can still use
        // a single ClientController but with different zoom behavior on each view.
        protected const float DEFAULT_ZOOM_MULTIPLIER = 0.01f;
        protected float _zoomMultiplier = DEFAULT_ZOOM_MULTIPLIER;
        protected float _zoomDelta;
        #endregion
        
        // constraints
        protected float _minZoom = 0.005f;
        protected float _maxZoom = 100000f;

        public ViewpointController(RenderingContext context)
        {
            if (context == null) throw new ArgumentNullException();
            mContext = context;
        }


		public System.Drawing.Point MouseScreenPosition { get {return mScreenPosition; } set { mScreenPosition = value;} }

        public float Zoom { get { return mContext.Zoom; } }
        public float ZoomMultiplier { get { return _zoomMultiplier; } set { _zoomMultiplier = value; } }
        public float MinZoom { get { return _minZoom; } set { _minZoom = value; } }
        public float MaxZoom { get { return _maxZoom; } set { _maxZoom = value; } }

        
        // Because each view can have a different view controller, we can still use
        // a single ClientController but with different zoom behavior on each view.
        private void ZoomIn(int mouseScrollAmount)
        {
            _zoomDelta = mouseScrollAmount * _zoomMultiplier;
#if DEBUG
            //if (_zoomDelta < 0.0f)
            //    // a lower zoom value brings us in closer because it will 
            //    // tell the camera to decrease the number of horizontal pixels visible
            //    System.Diagnostics.Debug.WriteLine("Zooming in.");
            //else
            //    // a higher total zoom value zooms us OUT because it will tell
            //    // the camera to increase the number of horizontal pixels visible
            //    System.Diagnostics.Debug.WriteLine("Zooming out.");
#endif
            float total = mContext.Zoom + _zoomDelta;
            total = (float)Utilities.MathHelper.Clamp(total, _minZoom, _maxZoom);

            // TODO: for component editor, our _minZoom should be 0.005f;
            //       and our _zoomMultiplier should also be 0.005f  
            //       but ideally these values modify as we hit certain
            //       trigger values in our current zoom, like powers of 10
            // TODO: or more likely, if our zoom values can be set on renderingcontext.customproperties
            //       we can simply configure the min/max zooms and multipliers based on the component's
            //       dimensions
            
            
            // TODO: this should be computed in Update() as part of Zoom behavior execution
            //       this way we only need store "Zoom" axis state
            mContext.Zoom = total;
        }

        private void ZoomOut(int mouseScrollAmount)
        {
            ZoomIn(mouseScrollAmount);
            return;
        }

        private bool IsMouseLookCompatibleViewMode()
        {
            if (mContext.ProjectionType == Viewport.ProjectionType.Orthographic)
                return false;
            return true;
        }
        
        
        // Inputs are commands that cause an entity to change what it is doing. 
        // They are "triggered" (or "called") by outputs - they cannot be manipulated directly.
        // Outputs are events that fire when an entity's state changes. For example, a timer
		// will have an output for reaching its end, a button an output for being pressed, and 
		// a door an output for coming to a close.
		// TODO: let's imagine how a button that can accept as an INPUT a "pressed" 
		//       event and as output, this button will open a door.  How?  Well
		//       I think these sorts of events are not intended for Behavior Trees.
		//       They are more like x3d ROUTEs and so allow for a simpler type of script
		//       writing for modders.
		
		// Well, let's say that some types of inputs can only be generated by
		// engine? Or even, lets say that the behavior tree will obviously only be
		// designed to look at certain inputs and even... maybe... the simpler
		// input/output trigger system clears those and so by the time the behavior
		// runs (if there is one assigned) those inputs are already processed?
		// I think in the short term, we'll use our EntityInput and have those set
		// to an Entity and allow our Behavior nodes to access and process them.
		// Or perhaps the default Behavior is just designed to do normal trigger routing		
        public struct EntityOutput 
        {
        	public string Name;         // input name we'll respond to
        	public bool Enabled;
        	public string TargetEntity; // !self
        	public string TargetInput;  // 
        	public object Parameter;    // value
        	public float Delay;         
        	public bool OnlyOnce;
        }
        
        internal void QueueInput (Entities.Entity.EntityInput input)
        {
            // NOTE: For viewports without viewpoint yet attached (eg. Tactical which waits for starship/Vehicle)
            //       the viewpoint may not be set yet.  No problem, just check for it.
            if (mContext.Viewpoint != null) 
            	mContext.Viewpoint.QueueInput (input);
        }
        
        
        
        public void SetAxisStateChange (string axisName, bool enabled, object args)
        {
        	// https://developer.valvesoftware.com/wiki/User_Inputs_and_Outputs
        	
        	switch (axisName)
        	{
	      		// Viewpoint BehaviorTree has nothing to do with selection, mouse hover, cancel and delete tool options
      			// Viewpoint Behavior is strictly for controlling position and orientation of the camera.
      			//
      			// TODO: Panning and Zoom are camera behaviors though and we should get that working
      			//
	        	// filter intrinsic reserved name Tool messages
	        	// tool updates are part of controller whereas Behavior Tree is for translation and orientation logic
				case "bind":
					break;
				case "leftclick":
					// TODO: another oversight... with select, delete, cancel, mousemove, 
    				if (enabled)
    					// TODO: originally i think, the keyboard binding was to emulate a different type of game.
                        // now this "select" just causes problems with other methods we use such as the Tools to 
                        // determine what is selected
    					mContext.Workspace.ToolMouseBeginLeftButtonSelect (mContext.Viewport, mScreenPosition);
    				else mContext.Workspace.ToolMouseEndLeftButtonSelect (mContext.Viewport, mScreenPosition);
					break;
                case "rightclick":
                    // TODO: another oversight... with select, delete, cancel, mousemove, 
                    if (enabled)
                        // TODO: originally i think, the keyboard binding was to emulate a different type of game.
                        // now this "select" just causes problems with other methods we use such as the Tools to 
                        // determine what is selected
                        mContext.Workspace.ToolMouseBeginRightButtonSelect(mContext.Viewport, mScreenPosition);
                    else mContext.Workspace.ToolMouseEndRightButtonSelect(mContext.Viewport, mScreenPosition);
                    break;
                case "delete":
					if (enabled)
						mContext.Workspace.OnEntityDeleteKeyPress ();
					break;
				case "use":
					break;
                case "control":
                    // alternate mouse behavior mode 
                    if (enabled)
                        mContext.Workspace.ToolKeyDown(axisName);
                    else mContext.Workspace.ToolKeyUp(axisName);
                    break;
				case "cancel":
					mContext.Workspace.ToolCancel();
					break;
				case "mousemove":   // mousemove is somewhat special in that currentTool must also be able to respond
				{
					mContext.Workspace.ToolMouseMove (mContext.Viewport, mScreenPosition);
					Entities.Entity.EntityInput input;
		        	input.Name = axisName;
		        	input.Source = "!device";
		        	input.Enabled = enabled ;
		        	input.Value = args;
		        	
		        	QueueInput (input);
					break;
				}
	        	default: // process user defined axis
				{
		        	Entities.Entity.EntityInput input;
		        	input.Name = axisName;
		        	input.Source = "!device";
		        	input.Enabled = enabled ;
		        	input.Value = args;
		        	
		        	QueueInput (input);
				}
	        	break;
        	}
        }
    
        // TODO: maybe mousescreen position should simply be set on here at start of Notify()
        public void Update (double elapsedSeconds)
        {
        	if (mContext.Viewpoint == null || mContext.Camera == null) return;
        	
        	int x, y; // viewport relative
        	mContext.Viewport.ScreenToViewport(mScreenPosition.X, mScreenPosition.Y, out x, out y);
        	System.Drawing.Point mouseEnd = new System.Drawing.Point (x, y);  
        	
        	// NOTE: we update Viewpoint entity here and not in Simulation since we only want binded viewpoints to get updated.
        	// Viewpoint.Update() will call any Behavior nodes that are controlling how the viewpoint responds to device input.
        	mContext.Viewpoint.Update (elapsedSeconds);

            // The behavior has applied new Translation and new Rotation 
            // to the Viewpoint entity but we still need to apply the
            // rotation to the camera.
        	mContext.Camera.Rotation = mContext.Viewpoint.Rotation ;      
        }
    }
}
