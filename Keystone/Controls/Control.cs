using System;
using Keystone.Events;
using Keystone.Entities;

namespace Keystone.Controls
{

    /// <summary>
    /// A Control is a type of Entity that has event handlers that can be directly wired and invoked.
    /// Thus, Control mimic's windows forms way of handling events.  The intent is that like Forms
    /// you can wire distinct handlers in the EXE for each specific GUI element.
    /// </summary>
    public class Control : ModeledEntity, IInputCapture // or simply IControl really
    {
        //private enum ControlState
        //{
        //    None,
        //    MouseOver,
        //    Pressed,
        //}

        // note that these events can be handled by a single super controller (e.g. ManipulatorController which is comprised of
        // multiple controls) that can handle the events for multiple controls.  So we dont have a 1:1 controller and control necessarily
        // we can have 1:Many 
        // Note: a controller is needed when a bunch of dependant controls are required to work together.  However in the future perhaps
        // a single type of GroupControl can handle this functionality instead of this concept of a "Controller".  This will make scripting
        // in general more elegant as you don't need these special hardcoded "controller" objects
        public event EventHandler KeyboardCancel;
        public event EventHandler MouseMove;
        public event EventHandler MouseEnter;
        public event EventHandler MouseLeave;
        public event EventHandler MouseDown;
        public event EventHandler MouseUp;
        public event EventHandler MouseClick;
        public event EventHandler MouseDrag;

        protected bool _capture = false;
        protected bool _captureEnabled = true;


       
        public Control(string id)
            : base(id)
        {
        }

        #region ITraverer
        public override object Traverse(Traversers.ITraverser target, object data)
        {
            return target.Apply(this, data);
        }
        #endregion

        public bool InputCaptureEnable { get { return _captureEnabled; } set { _captureEnabled = value; } }
        public bool HasInputCapture {get { return _capture;}}

        // event's that come here are (for now at least) _always_ generated by the engine
        // itself from input management.  Or to put it another way, never user generated.
        // Thus there is no issue of having to map input event names with event handler script names
        // or any such thing.  
        // I've gone back and forth a few times on the value of "controllers" and I think that a controller is
        // in fact necessary for proper Model View IOController seperation.  IOController should not exist
        // in a button, but rather a controller should initialize to map event handlers to controls that exist.
        // Yes, this does beg the question of how do we properly handle that specifically with regard
        // to paging sections in and out and thus controls and their Controllers in and out but that could conceptually
        // for now, be done by proper naming the target entity (control) and the name of the event.
        public virtual void HandleEvent(EventType et, InputCaptureEventArgs args)
        {
            switch (et)
            {
                case EventType.MouseMove:
                    if (_capture)
                    {
                        if (MouseDrag != null)
                        {
                            MouseDrag.Invoke(this, args);
                        }
                    }
                    else if (MouseMove != null) 
                        MouseMove.Invoke(this, args);
                    break;
                case EventType.MouseEnter:
                    // TODO: fix after Entity.Model done-> _appearanceFlags = (int)ControlState.MouseOver;
                    if (MouseEnter != null) MouseEnter.Invoke(this, args);
                    break;
                case EventType.MouseLeave:
                    // TODO: fix after Entity.Model done-> _appearanceFlags = (int) ControlState.None; // TODO: but not if we're currently depresed right?
                    // i think we're ok, cuz when captured we'll never get here from the top of the switch statement
                    if (MouseLeave != null) MouseLeave.Invoke(this,args);
                    break;
                case EventType.MouseLeftClick:
                    if (MouseClick != null) MouseClick.Invoke(this, args);
                    break;
                // TODO: an open question: Should we track our own state for things like rollover?  well somewhat.
                    // i believe if we rely on the events we can just change state directly without intermediate variables
                    // But on the issue of mouse capturing, what windows does is manage which controls have focus and such
                // http://social.msdn.microsoft.com/Forums/en-US/winforms/thread/25df6446-65e7-4118-b236-cfbc350c2687/
                    // so we should do the same.  We can have a default manager for the basic core stuff like enter, leave, down, up, etc
                    // but then the other events we generate which a user will respond too such as Click() are the main ones to be customized
                case EventType.MouseDown :
                    _capture = true;
                    if (MouseDown != null) MouseDown.Invoke(this, args);
                    break;
                case EventType.MouseUp:
                    _capture = false;
                    // TODO: will this false popsitive MouseUp if control never received mouseDown but then a depressed mouse
                    // is hovered over and released?  it shouldnt
                    if (MouseUp != null) MouseUp.Invoke(this, args);
                    if (MouseClick != null) MouseClick.Invoke(this, args);
                    break;
            }
        }
    }
}
