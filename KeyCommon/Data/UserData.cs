using System;
using System.Collections.Generic;
using Keystone.Types;

namespace KeyCommon.Data
{

	// http://www.gamasutra.com/view/news/38977/InDepth_Behavior_Tree_Entrails.php
	// An agent's blackboard aggregates all agent specific game world knowledge. 
	// It's the only data immediate action functions are allowed to access to keep
	// cache misses at bay. A blackboard data structure might just be a C struct with
	// fields like used by Halo 2 or a key-value dictionary. It's favorable if the
	// blackboard can be stored as a data blob that's easily kept or streamed into 
	// local memory/cache.
	// https://social.technet.microsoft.com/wiki/contents/articles/13461.blackboard-design-pattern-a-practical-example-radar-defense-system.aspx
	// Blackboard is a design pattern that also requires it be threadsafe.	Blackboard
	// is great for sharing knowledge.
	// http://www.codeproject.com/Articles/451326/Type-safe-blackboard-property-bag
	public class UserData 
	{
		// http://www.gamasutra.com/view/news/198377/Video_Valves_system_for_creating_AIdriven_dynamic_dialog.php
		// http://www.valvesoftware.com/publications/2012/GDC2012_Ruskin_Elan_DynamicDialog.pdf
		// NOTE: in Valve's Zombie game, for the npc voice logic, they share
		//       all of this knowledge in a single knowledge base rather than allowing
		//       each to have it's own in a fragmented way and it makes running through
		//       them sequentially to find voice responses that match a search much faster and easier.
		//       Valve's Left 4 Dead voice logic is very much a flat database but generated by flattening
		//		 a scenegraph style directed acyclic graph (DAG))	
		//		 - The trick is how the KEY for each flattened path is created and then used when building the query string!!!		
		//		http://www.gamasutra.com/blogs/GuyHasson/20120706/173705/Story_Design_Tips_Better_NPC_Interaction_Part_II.php
		//			- sort rules alphabetically.  Why?
		//				- well this way when running the comparisons of the QUERIES against the CONDITIONS of each rule,
		//			as we iterate through each QUERY "key" we don't have to re-start an iteration at the beginning of every CONDITION "key" 
		//			because we know they are in same alphabetical order as the QUERIES collection.  For instance:
		//			QUERY: A:100, B:50, C:true, F:false
		//			RULE1:
		//          	CONDITIONS: A:<=500 && A: >=0 
		//              CONDITIONS: C:<=True && >=True
		//				- in the above, we start to iterate through the 4 query tuples and for each naivly we iterate each CONDITION
		//                but instead, when we find a matching condition, we don't need to start over.  We can resume because we know that
		//                the CONDITIONS are sorted the same way so when testing QUERY part B, we can resume iteration of CONDITION and next
		//				  CONDITION will be C: so we know B doesn't exist (else the iteration cursor would have been moved back to beginning).		
		//
		//          TODO: currently our normal propertybag stores it's data as DefaultValue and does not actually hook back to a
		//			      collection of objects.  It should actually store to same object store so that the data can also be read
		//                directly through the object store and not through the entity.  Recall that originally, the point of using the PropertySpec's
		//                was to get propertybag GUI rendering for free via propertygrid control.
		//
		//			- hash buckets for different regions and/or other basic buckets similarly to what we do when we cull
		//			- store pointers to the value we want to compare rather than have to query that game data
		//			- sort by decreasing # of criteria (as we do with TileMap auto-tile rules)
		//			- represent every comparision as a >= x >= b  
		//				eg.   return (10 >= ptrCharacterXHitpoints && ptrCharacterXHitpoints >= 100);    
		//
		//		So in a way, what we want there is a Blackboard class that can
		//       manage all that for us, and then when we first initialize a behavior
		//       on an Entity, it will grab a blackboard blob from the allocator and
		//       assign it to the Enity.Knowledge
		//       - and since the dialogue tree structure is essentially a flattened DAG (like a scenegraph)
		//		 which seems to take on a Rules Engine like functionality because it becomes serial
		//       test and not a branching test.
		//       -thus, each "record" has an owner and can be referenced and read/written to
		//       from the UserDataStore.  There is a question of whether this data should remain in 
		//       DB form.. perhaps cached for recent access.  Well, i think it must be cached or else
		//       way too slow for the type of use we do.  Do we CheckIn/CheckOut data blobs?  We could do some
		//       really fast computations I think and threaded, on an in memory "blackboard" where each blackboard 
		//       can be defined and hold all of same record types (eg all stars, all worlds, all npcs) so that
		//       manipulation of their data is... well... its all very functional style and not OO.
		//		 - THE CACHE COHERENCY BECOMES EXCELLENT.
		//		   - perhaps each derived blackboard itself becomes a data manipulator that knows how to read/write it's data
		//	       and then the sqlite or whatever storage occurs as generic using array of field definitions
		//			- Being able to define custom blackboards is nice because we now have fixed size fields
		//
		//		 - is the UserDataStore a global like Pager and Repository?
		//		- maybe each Blackboard gets instantiated EXE side and so we get StarData : UserData 
		//      that gets used for all stars and which we can write custom data manipulation against
		//		- we could even read/write to it like we do with Packets... and perhaps even use unsafe code for even greater performance
		// (See E:\dev\_projects\_XNA\Mercury Particle Engine\ProjectMercury.WindowsEmitters\Emitter.cs.Update() method)
		// but one thing it does which i think defeats the purpose somewhat perhaps is it creates a fixed pointer to the particle array rather than allocating it as pointer from start.  having to "fix" it seems like enough overhead to nullify any performance advantages
		
		//  - Production productID and Consumers can be stored here as well.  Do we still want to use scripts for these entities? or
		//    would scripts assigned to each data store type be more efficient?
		//  - for economic simulation this could be very fast
		//	- AI simulation may be more needed case for a single player 1.0 game release
		//		- blackboard data can store Area_Of_Interest data generated from other pre- calculations 
		//  - for NPC simulation this can be very fast too when running out behavior tree against this data
		//    and eventually we probably stop simulating Entity AI in Entity.Update() and move it to an Update() 
		//    of simulation that will iterate through npcs by iterating through the blackboard data (limiting iterating 
		//    to X count that fit into an alotted timeslice using threading as available and as needed)
		
		//		- IN OTHER WORDS, by iterating through the array of UserData to perform entity updates, can we properly update
		//    these variables with appropriate functions and have the update reflected in the Entity itself?  For example, lets say
		//    we have 50 entities that are doing wander steering behavior... can we run a singular script that operates on blackboard user data
		//    to update all 50 of those entities?  rather than 50 calls to entity.update() and 50 script calls.
		//          - if the scripts each entity uses can be one of the ways we sort entities when updating their data, then we can easily
		//          update all entities using a particular script.... similar to how we do renders of sorted entities
		//			- if our scene update() loop added entities to be updated in sorted buckets... but for now this is jsut brainstorming idea, since it could slow us down
		//
		
		// TODO: google cache coherency as it relates to flat databases 
		//			- and .net c#
		// TODO: isn't BehaviorContext.Knowledge already associated with Entity?  And shouldn't this data replace Entity CustomProperties? and Rename var from Knowledge to Entity.CustomData
                                   //       and is now stored in sqlite where our scene representation which uses xml is seperate from the entity custom data which is db stored.  Our EntityAPI for
                                   //       getting custom data can now also use methods with type safety.  Further we no longer have to care about custom data being serialized to xml and perhaps this
                                   //       speeds up our ability to save scene when we are editing maps as well as saving game state
        							// TODO: however, will this type of CustomProperties now no longer be easily editable in a PropertyGrid and if not, is that ok?
        							//      we're using custom html interfaces now anyway right?
        							//      we must start with _just_ custom properties for now but actually just RenderingContext 
        							// TODO: also what about shaders?  right now those use custom properties for shader params/vars and should not be stored in a db!
        							// TODO: actually volume, surfacearea,cost,weight for all celestial bodes is already being used as custom properties!
        							//       So question is, how do we connect those to a datastore?
        							//		 - well just as we use GetProperties() SetProperties() where a single reader/writer of xml store is operating
        							//       we can do same for UserData.   We can convert to GetProperties and SetProperties() and we can also
        							//       use other methods of iterating thru the list of custom data. For now, let's just focus on Viewpoint for Chase
        					
		// is there a way to track the data for an individual Entity via an Index into array of records and to have this record
		// index maintained during lifetime? indices can be checked in / checked out

		// locally, we dont really need to use entityID as part of a record key either, locally we can use just an Index
		// and perhaps a lookup value... but i think in short term, we should continue to focus on just Viewpoint and Chase cam
		// and if that goes well, Stars and see about how it works with LoadTVResource() and restoring DB via a LoadCustomData()
        							
		bool Initialized = false;      // first run? if knowledge is not initialized, then we should select initialization node first
                                       // TODO: is it useful to store these by type?  so bools, timestamps, vector3d, strings, ints, etc?
                                       //	System.Collections.Hashtable BehaviorState;
                                       //	System.Collections.Hashtable AxisState;
                                       //	System.Collections.Hashtable TimeStamps;  // when a target was seen, when received damage, when ally died, 
                                       // Stimulii <-- not sure... is this like timestamps where we learn if we've just consumed explosive damage from an explosive producer?


        // TODO: I could/should just use a Template here!
        // TODO: if everything was an object and I just used the "GetInteger()" for example, as helper method to do a cast for me since i know the type represented by each key value
        //       then perhaps i could jsut avoid all of these dictionaries? perhaps at least, have dictionaries that are now key'ed into buckets
        //       by entityID and/or by regionID and then entityID.	The point is though
        //       by storing them in a Dictionary as object, I can query the value by maintaining a reference to that object in a Rule
        //       so that when running these rules, i dont have to perform the lookup in the collection for the value.  I just have to do a cast.	
        //private int ID; // ID should (but not required) to be unique amongst all Entities and combined with an iterator count, can be used for deterministic random seeds.
        // https://www.gamedeveloper.com/programming/a-primer-on-repeatable-random-numbers
        //private int mCounter; // every traversal of the behavior tree increments this value by 1 and potentially every decision made during traversal where a Random number is needed, can increment this counter.	
		private Dictionary <string, object> Objects;
		private Dictionary <string, string> Strings;
        private Dictionary <string, string[]> StringArray;
		private Dictionary <string, bool> Bools;
		private Dictionary <string, int> Integers;
		private Dictionary <string, float> Floats;
		private Dictionary <string, double> Doubles;
		private Dictionary <string, System.Drawing.Point> Points;
		private Dictionary <string, Keystone.Types.Vector3d> Vectors;
		private Dictionary <string, Vector3d[]> Vector3dArrays;
		private Dictionary <string, Keystone.Types.Quaternion> Quaternions;
		private Dictionary <string, Keystone.Types.Color> Colors;

        // https://github.com/wuyuntao/BehaveAsSakura/tree/master
        // TODO: if we enforced all fields first, then we could do a fixed layout
        //       but if that's the case, we might as well just use struct{}
        //       However, also it could be better if the key for all of these
        //       is tied to the Entity so that we have key = entity.ID + ":" + name
        //       and this way we can use a single set of Dictionaries (or in the future, arrays)
        //       to store everything.  The problem is with arrays, we could use a lookup for the entity ID
        //       to find the index for the record, then use sub-index for the specific field
        // TODO: Collections field could be used perhaps to store nested Data?
        private Dictionary <string, UserData> Collections;

        public UserData()
        {
        }

		public UserData Clone ()
		{
			UserData copy = new UserData ();

            // TODO: a single array of object would consume less memory
            //       and cloning it would not require we maintain the code whenever we add
            //       a new generic Dictionary type.
            // 
            //  and then why not then use "custom properties" or something?
            //  our PropertyTable is a type of blackboard too... but its main
            //  feature is that it allows for use with a propertyGrid
            //  We could maybe streamline it... but it uses just flat array instead of
            //  dictionary.  
            //  Also, even our "custom properties" could use same array as our regular properties
            //  only we could add them to a category of "custom" properties instead
            //  so that when serializing we can skip them

            // our IEntityAPI can still use special accessors for get/set so that caller in script
            // does not have to specify a category, but actually i dont think thats necessary.  they are
            // only keyed by property name, not name and category.
            // 
            // Also, we can still do database storage easily using a DataObject wrapper around our Properties.
            // or well maybe scrach that, since our normal properties are linked to intrinsic property fields 
            // in those Entities like _translation and _scale and _orientation, but our Behavior nodes can still
            // access those as blackboard knowledge...

            // so i think our 'UserData' interface should merge with "CustomProperties" in the short term 
            // and be cloneable.  at the least instead of spec.DefaultValue, we should be using actual
            // UserData[key]  to store the value.
            throw new NotImplementedException();
            return null;
		}

        public object GetObject(string name)
        {
            return Objects[name];
        }
        public void SetObject(string name, object value)
        {
            if (Objects == null)
                Objects = new Dictionary<string, object>();

            if (Objects.ContainsKey(name))
                Objects[name] = value;
            else
                Objects.Add(name, value);
        }

        public string GetString (string name)
		{
			return Strings[name];
		}
		public void SetString (string name, string value)
		{
			if (Strings == null)
					Strings = new Dictionary<string, string> ();
			
			if (Strings.ContainsKey(name))
				Strings [name] = value;
			else   				
				Strings.Add (name, value);
		}

        public string[] GetStringArray(string name)
        {
            return StringArray[name];
        }

        public void SetStringArray(string name, string[] value)
        {
            if (StringArray == null) StringArray = new Dictionary<string, string[]>();
            StringArray[name] = value;
        }

		public bool GetBool (string name)
		{
			return Bools[name];
		}
		public void SetBool (string name, bool value)
		{
			if (Bools == null)
					Bools = new Dictionary<string, bool> ();
			
			if (Bools.ContainsKey(name))
				Bools [name] = value;
			else   				
				Bools.Add (name, value);
		}
		
		public int GetInteger (string name)
		{
			return Integers[name];
		}
		public void SetInteger (string name, int value)
		{
			if (Integers == null)
				Integers = new Dictionary<string, int> ();
			
			if (Integers.ContainsKey(name))
				Integers [name] = value;
			else   				
				Integers.Add (name, value);
		}
		
		public double GetDouble (string name)
		{
			return Doubles[name];
		}
		public void SetDouble (string name, double value)
		{
			if (Doubles == null)
					Doubles = new Dictionary<string, double> ();
			
			if (Doubles.ContainsKey(name))
				Doubles [name] = value;
			else
				Doubles.Add (name, value);
		}
		
		public float GetFloat (string name)
		{
			return Floats[name];
		}
		public void SetFloat (string name, float value)
		{
			if (Floats == null)
					Floats = new Dictionary<string, float> ();
			
			if (Floats.ContainsKey(name))
				Floats [name] = value;
			else
				Floats.Add (name, value);
		}
		    			
		public System.Drawing.Point GetPoint (string name)
		{
			return Points [name];
		}
		public void SetPoint (string name, System.Drawing.Point value)
		{
			if (Points == null)
				Points = new Dictionary<string, System.Drawing.Point> ();
				
			if (Points.ContainsKey(name))
				Points [name] = value;
			else
				Points.Add (name, value);

		}
		
		public Vector3d GetVector (string name)
		{
			return Vectors [name];
		}
		public void SetVector (string name, Vector3d value)
		{
			if (Vectors == null)
				Vectors = new Dictionary<string, Vector3d> ();
				
			if (Vectors.ContainsKey(name))
				Vectors [name] = value;
			else
				Vectors.Add (name, value);
		}

		public Vector3d[] GetVector3dArray (string name)
		{
			return Vector3dArrays [name];
		}
		public void SetVector3dArray (string name, Vector3d[] value)
		{
			if (Vector3dArrays == null)
				Vector3dArrays = new Dictionary<string, Vector3d[]> ();
				
			if (Vector3dArrays.ContainsKey(name))
				Vector3dArrays [name] = value;
			else
				Vector3dArrays.Add (name, value);
		}
		
		
		public Quaternion GetQuaternion (string name)
		{
			return Quaternions [name];
		}
		public void SetQuaternion (string name, Quaternion value)
		{
			if (Quaternions == null)
				Quaternions = new Dictionary<string, Quaternion> ();
				
			if (Quaternions.ContainsKey(name))
				Quaternions [name] = value;
			else
				Quaternions.Add (name, value);
		}
	}
}
